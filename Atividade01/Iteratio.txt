class MenuItem {

	String nome;
	
	MenuItem(String nome) {
		this.nome = nome;
	}
	
}

interface Iterator {
	boolean hasNext();
	Object next();
}

public class MenuIterator implements Iterator {

	MenuItem[] itens;
	int posicao = 0;
	
	public MenuIterator(MenuItem[] itens) {
		this.itens = itens;
	}
	
	public Object next() {
		MenuItem menuItem = itens[posicao];
		posicao++;
		return menuItem;
	}
	
	public boolean hasNext() {
		if (posicao >= itens.length || itens[posicao] == null) {
			return false;
		} else {
			return true;
		}
	}
	
} ////////////////////////////////////////////
No exemplo acima temos a classe principal MenuItem que é simplesmente um item de um menu que possui um nome, este poderia ser um menu que apareceria na seção de menu de um site, por exemplo.

Abaixo temos a interface “Iterator” que é implementada pela classe “MenuIterator” que será responsável por iterar pela coleção de menus que estará em algum tipo de coleção de objetos como uma matriz ou um ArrayList. Uma situação interessante de se pensar sobre a utilidade deste padrão é na situação em que, por exemplo, se tivéssemos uma classe que cria uma coleção de menus e depois precisaríamos percorrer esse menu para mostrar tudo que há nesta coleção, como você implementaria sem utilizar a interface Iterator e a classe MenuIterator acima? Segue abaixo uma possível solução de como resolveríamos este problema:

Listagem 2: Exemplo de iteração sobre os menus

public class MostraMenu {
	public static void main(String args []) {
		MenuItem [] menuItens = new MenuItem[4];
		
		menuItens[0] = new MenuItem("Menu 1");
		menuItens[1] = new MenuItem("Menu 2");
		menuItens[2] = new MenuItem("Menu 3");
		menuItens[3] = new MenuItem("Menu 4");
		
		for (int i=0; i < menuItens.length; i++) {
			System.out.println(menuItens[i].nome);
		}
		
	}
}///////////////////////////////////////////////////
No exemplo acima podemos notar que a iteração está toda visível no meio da classe, e se tivéssemos essa iteração em diversas classes e agora precisaríamos mudá-la, pois o tipo da coleção também sofreu alterações? E se agora fosse um Hashmap de menus e não mais uma matriz? Teríamos que mudar também a iteração. Pode-se imaginar o trabalho que isso daria.

Por isso anteriormente criamos a interface Iterator e a classe de implementação MenuIterator para os Menus. Abaixo segue uma possível utilização do padrão Iterator para percorrer uma coleção de objetos de menu:

Listagem 3: Exemplo de iteração sobre os menus usando o padrão Iterator

public class MostraMenu {
	public static void main(String args []) {
		MenuItem [] menuItens = new MenuItem[4];
		
		menuItens[0] = new MenuItem("Menu 1");
		menuItens[1] = new MenuItem("Menu 2");
		menuItens[2] = new MenuItem("Menu 3");
		menuItens[3] = new MenuItem("Menu 4");
		
		Iterator menuIterator = new MenuIterator(menuItens);
		
		while (menuIterator.hasNext()) {
			MenuItem menuItem = (MenuItem)menuIterator.next();
			System.out.println(menuItem.nome);
		}
	}
}
Podemos notar que toda a estrutura interna do iterador foi abstraída pelo Padrão de Projeto Iterator ficando de uma forma muito mais limpa e clara. A única coisa que utilizamos são os métodos next() e hasNext().

Vantagens do Padrão Iterator
O Padrão Iterator encapsula as implementações das iterações, a partir de agora não precisamos mais ver que tipo de coleção está sendo utilizada pelos objetos como um ArrayList ou um HashTable. Com a utilização do Padrão Iterator precisamos apenas de um loop para lidarmos polimorficamente com qualquer coleção de itens desde que ela apenas implemente o Iterator. Anteriormente também estávamos com o código vinculado a classes como ArrayList, agora usamos apenas uma interface (Iterator), lembre-se de programar sempre para interfaces.

Conclusão
O Padrão Iterator permite o acesso sequencial aos elementos de um agregado sem expor a sua implementação subjacente. O Padrão Iterator também é responsável por toda a tarefa de iteração, retirando assim do agregado a responsabilidade, dessa forma simplificando a interface e a sua implementação deixando a responsabilidade onde deveria estar. Por fim, o padrão Iterator nos remete a dois princípios de bons projetos que é da alta coesão com as classes projetadas em torno de um conjunto de funções relacionadas entre si e da Responsabilidade Única, onde a classe possui uma única finalidade ou responsabilidade. Apesar da coesão ter um conceito mais genérico, ela está estritamente relacionada com o conceito da Responsabilidade Única.